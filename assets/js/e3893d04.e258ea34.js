"use strict";(globalThis.webpackChunkhumanoid_robotics_book=globalThis.webpackChunkhumanoid_robotics_book||[]).push([[8183],{5045:(i,n,e)=>{e.r(n),e.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"digital-twin/physics-simulation","title":"Physics Simulation (Rigid Bodies, Collisions, Gravity)","description":"Chapter 04:","source":"@site/docs/02-digital-twin/04-physics-simulation.md","sourceDirName":"02-digital-twin","slug":"/digital-twin/physics-simulation","permalink":"/hackathon-1/docs/digital-twin/physics-simulation","draft":false,"unlisted":false,"editUrl":"https://github.com/FareaaFaisal/hackathon-1/edit/main/docs/02-digital-twin/04-physics-simulation.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4,"title":"Physics Simulation (Rigid Bodies, Collisions, Gravity)"},"sidebar":"tutorialSidebar","previous":{"title":"SDF vs URDF Pipelines","permalink":"/hackathon-1/docs/digital-twin/sdf-vs-urdf"},"next":{"title":"Sensor Simulation","permalink":"/hackathon-1/docs/digital-twin/sensor-simulation"}}');var t=e(4848),r=e(8453);const a={sidebar_position:4,title:"Physics Simulation (Rigid Bodies, Collisions, Gravity)"},o=void 0,l={},c=[{value:"Chapter 04:",id:"chapter-04",level:2},{value:"4.1 Physics Engines in Gazebo",id:"41-physics-engines-in-gazebo",level:2},{value:"Selecting a Physics Engine",id:"selecting-a-physics-engine",level:3},{value:"4.2 Rigid Body Dynamics",id:"42-rigid-body-dynamics",level:2},{value:"4.3 Collisions",id:"43-collisions",level:2},{value:"4.4 Gravity",id:"44-gravity",level:2},{value:"4.5 Validating Humanoid Balance",id:"45-validating-humanoid-balance",level:2},{value:"4.6 Summary",id:"46-summary",level:2},{value:"4.7 Learning Outcomes",id:"47-learning-outcomes",level:2},{value:"References",id:"references",level:2}];function d(i){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h2:"h2",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...i.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"chapter-04",children:"Chapter 04:"}),"\n",(0,t.jsx)(n.p,{children:"This chapter focuses on configuring physics engines and validating humanoid balance simulations."}),"\n",(0,t.jsxs)(n.p,{children:["Accurate physics simulation is essential for testing ",(0,t.jsx)(n.strong,{children:"humanoid robots"})," in a virtual environment. By simulating rigid body dynamics, collisions, and gravity, engineers can validate balance, motion planning, and interaction with the environment before deploying to real hardware."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"41-physics-engines-in-gazebo",children:"4.1 Physics Engines in Gazebo"}),"\n",(0,t.jsx)(n.p,{children:"Gazebo supports multiple physics engines, including:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"ODE (Open Dynamics Engine)"})," \u2013 default, general-purpose rigid body simulation."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Bullet"})," \u2013 supports advanced collision and contact modeling."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"DART (Dynamic Animation and Robotics Toolkit)"})," \u2013 ideal for humanoid and legged robots."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Simbody"})," \u2013 accurate multibody simulation with advanced constraints."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"selecting-a-physics-engine",children:"Selecting a Physics Engine"}),"\n",(0,t.jsxs)(n.p,{children:["Physics engines are configured in ",(0,t.jsx)(n.strong,{children:"world files"})," using the ",(0,t.jsx)(n.code,{children:"<physics>"})," tag:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:'<physics type="ode" name="default_physics">\r\n  <max_step_size>0.001</max_step_size>\r\n  <real_time_factor>1.0</real_time_factor>\r\n  <gravity>0 0 -9.81</gravity>\r\n</physics>\n'})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"max_step_size: The simulation time step for integration. Smaller values increase accuracy but reduce speed."}),"\n",(0,t.jsx)(n.li,{children:"real_time_factor: Ratio of simulation time to real time."}),"\n",(0,t.jsx)(n.li,{children:"gravity: Sets the gravity vector (m/s\xb2)."}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:(0,t.jsx)(n.strong,{children:"Definition:"})})," Physics Engine: Software component that simulates forces, collisions, and rigid body dynamics."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"42-rigid-body-dynamics",children:"4.2 Rigid Body Dynamics"}),"\n",(0,t.jsx)(n.p,{children:"A rigid body is an idealized physical object that does not deform under forces. Each link of a humanoid robot is modeled as a rigid body with mass, inertia, and collision properties."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:'<link name="torso_link">\r\n  <inertial>\r\n    <mass value="10"/>\r\n    <inertia ixx="1" ixy="0" ixz="0" iyy="1" iyz="0" izz="1"/>\r\n  </inertial>\r\n</link>\n'})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Mass:"})," Influences acceleration and stability."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Inertia matrix:"})," Determines resistance to rotational motion."]}),"\n",(0,t.jsx)(n.li,{children:"Accurate values are essential to maintain humanoid balance."}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"43-collisions",children:"4.3 Collisions"}),"\n",(0,t.jsx)(n.p,{children:"Collisions define how rigid bodies interact when they come into contact. Gazebo uses collision geometry defined in links:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:'<collision>\r\n  <geometry>\r\n    <box size="0.5 0.2 0.8"/>\r\n  </geometry>\r\n</collision>\n'})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Correct collision shapes prevent interpenetration of links."}),"\n",(0,t.jsx)(n.li,{children:"Simplified collision geometry can improve simulation speed but may reduce realism."}),"\n",(0,t.jsx)(n.li,{children:"Use visual meshes for rendering and collision meshes for physics calculations."}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:(0,t.jsx)(n.strong,{children:"Definition:"})})," Collision Shape: The geometric approximation of a rigid body used by the physics engine to detect and respond to contact events."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"44-gravity",children:"4.4 Gravity"}),"\n",(0,t.jsx)(n.p,{children:"Gravity ensures realistic motion and humanoid balance. Standard gravity is -9.81 m/s\xb2 along the Z-axis. Proper gravity configuration allows:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Testing standing, walking, and dynamic movements."}),"\n",(0,t.jsx)(n.li,{children:"Evaluating stability under perturbations."}),"\n",(0,t.jsx)(n.li,{children:"Planning realistic trajectories and control strategies."}),"\n"]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Tip: Always verify that the humanoid's center of mass is correctly modeled to prevent unrealistic tipping or sliding."}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"45-validating-humanoid-balance",children:"4.5 Validating Humanoid Balance"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Static Balance Test:"})," Ensure the robot maintains upright posture when standing."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Dynamic Balance Test:"})," Simulate walking or shifting weight using joint controllers."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Collision Response:"})," Push the robot virtually and observe correct physics-based reactions."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Inertia Check:"})," Verify that heavy links react realistically to applied forces."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Example:"})," In Gazebo, apply a force to the torso:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:'ros2 topic pub /torso_link/force geometry_msgs/msg/Wrench "{force: {x: 50, y: 0, z: 0}, torque: {x:0, y:0, z:0}}"\n'})}),"\n",(0,t.jsx)(n.p,{children:"Observe how the robot\u2019s joints and base respond according to mass and inertia."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"46-summary",children:"4.6 Summary"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Physics engines simulate rigid bodies, collisions, and gravity to enable realistic humanoid behavior."}),"\n",(0,t.jsx)(n.li,{children:"Accurate mass, inertia, and collision properties are critical for humanoid balance."}),"\n",(0,t.jsx)(n.li,{children:"Validating static and dynamic balance ensures that robots perform safely in real-world environments."}),"\n",(0,t.jsx)(n.li,{children:"Proper configuration of step size, gravity, and real-time factors improves simulation fidelity."}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"47-learning-outcomes",children:"4.7 Learning Outcomes"}),"\n",(0,t.jsx)(n.p,{children:"After completing this chapter, students will be able to:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Configure and select suitable physics engines for humanoid robotics."}),"\n",(0,t.jsx)(n.li,{children:"Understand rigid body dynamics and their importance in robot balance."}),"\n",(0,t.jsx)(n.li,{children:"Set up collision shapes and validate realistic interaction with the environment."}),"\n",(0,t.jsx)(n.li,{children:"Adjust gravity and simulation parameters for accurate humanoid motion."}),"\n",(0,t.jsx)(n.li,{children:"Validate the physical accuracy of humanoid robot models in simulation."}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,t.jsx)(n.p,{children:"[1] Koenig, N., Howard, A., \u201cDesign and Use Paradigms for Gazebo, an Open-Source Multi-Robot Simulator,\u201d IEEE/RSJ IROS, 2004."}),"\n",(0,t.jsx)(n.p,{children:"[2] Siciliano, B., et al., Springer Handbook of Robotics, 2nd ed., Springer, 2016."}),"\n",(0,t.jsxs)(n.p,{children:["[3] ROS 2 Documentation, \u201cGazebo Physics Properties,\u201d ",(0,t.jsx)(n.a,{href:"https://docs.ros.org/en/humble/Tutorials/Simulation/Gazebo-Physics.html",children:"https://docs.ros.org/en/humble/Tutorials/Simulation/Gazebo-Physics.html"})]}),"\n",(0,t.jsxs)(n.p,{children:["[4] Open Dynamics Engine Documentation, ",(0,t.jsx)(n.a,{href:"https://www.ode.org/ode-latest-userguide.html",children:"https://www.ode.org/ode-latest-userguide.html"})]}),"\n",(0,t.jsxs)(n.p,{children:["[5] DART Physics Engine Documentation, ",(0,t.jsx)(n.a,{href:"https://dartsim.github.io/website/",children:"https://dartsim.github.io/website/"})]}),"\n",(0,t.jsx)(n.hr,{})]})}function h(i={}){const{wrapper:n}={...(0,r.R)(),...i.components};return n?(0,t.jsx)(n,{...i,children:(0,t.jsx)(d,{...i})}):d(i)}},8453:(i,n,e)=>{e.d(n,{R:()=>a,x:()=>o});var s=e(6540);const t={},r=s.createContext(t);function a(i){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof i?i(n):{...n,...i}},[n,i])}function o(i){let n;return n=i.disableParentContext?"function"==typeof i.components?i.components(t):i.components||t:a(i.components),s.createElement(r.Provider,{value:n},i.children)}}}]);